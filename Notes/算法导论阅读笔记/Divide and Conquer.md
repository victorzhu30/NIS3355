### 1. **传统数学归纳法**
在传统的数学归纳法中，证明某个命题 \( P(n) \) 对于所有 \( n \geq n_0 \) 成立，通常包括以下步骤：

- **基例**：首先证明命题对某个初始值（通常是最小值 \( n_0 \)）成立。也就是证明 \( P(n_0) \) 成立。
- **归纳步骤**：假设 \( P(k) \) 对于某个 \( k \geq n_0 \) 成立，即假设 \( P(k) \) 对 \( k = n \) 成立，然后要证明 \( P(k+1) \) 也成立。

这是用于非递归公式（比如数列、等式等）的典型归纳法。

### 2. **递归关系的归纳法**
当我们处理递归算法的时间复杂度时，问题的结构不同，因为递归式涉及算法自身对更小规模问题的调用。此时，我们证明时间复杂度的归纳法使用了递归的结构特点，所以看起来有所不同。主要区别在于：

- **递归关系**：递归式描述了问题的解决方案如何递归地依赖于更小规模的子问题（比如 \( T(n) \) 是通过 \( T(n/2) \) 或更小子问题计算出来的）。
  
- **归纳假设**：你不再是直接假设 \( T(n) \) 对 \( n \) 成立，而是假设对于比 \( n \) 小的所有子问题（如 \( \lfloor n/2 \rfloor \)）的复杂度已经符合你的猜测。然后，你基于这个假设来证明整个问题（即 \( n \) 的问题）也符合你的猜测形式。

#### 区别具体体现在：
- **传统数学归纳法**：假设对 \( n \) 成立，证明 \( n+1 \) 成立。
- **递归关系的归纳法**：假设对比 \( n \) 小的所有问题（例如 \( \lfloor n/2 \rfloor \)）成立，然后证明对 \( n \) 也成立。

### 举例：
假设我们有一个递归关系式：

\[
T(n) = 2T(\lfloor n/2 \rfloor) + \Theta(n)
\]

我们想证明 \( T(n) \) 的上界是 \( O(n \log n) \)。用归纳法的步骤是：

1. **归纳假设**：假设对于所有比 \( n \) 小的子问题，递归关系已经满足上界，即对于 \( T(\lfloor n/2 \rfloor) \leq c \lfloor n/2 \rfloor \log \lfloor n/2 \rfloor \)。
2. **归纳步骤**：将这个假设代入原始递归关系式，看看对 \( T(n) \) 是否也满足上界形式。我们代入：

   \[
   T(n) \leq 2 \cdot T(\lfloor n/2 \rfloor) + \Theta(n) \leq 2 \cdot c (n/2) \log(n/2) + \Theta(n)
   \]

   通过化简得到：

   \[
   T(n) \leq c n \log n - c n + \Theta(n)
   \]

   通过适当选择常数 \( c \) 和 \( n_0 \)，我们可以确保该公式对 \( n \) 成立。

3. **基例**：证明递归的基准情况（如 \( n = 2 \) 或 \( n = 3 \)）满足设定的时间复杂度形式。

### 总结：
- **传统归纳法**：用于非递归问题，证明从 \( n \) 推到 \( n+1 \)。
- **递归归纳法**：用于递归问题，假设较小规模的子问题满足某个猜测的形式，通过递归关系验证整个问题的复杂度。

### 1. **归纳假设**：
归纳假设是：对于比 \( n \) 小的所有值，递归关系已经满足上界，即：

\[
T(\lfloor n/2 \rfloor) \leq c \lfloor n/2 \rfloor \log(\lfloor n/2 \rfloor)
\]

这是归纳法的基础假设，意思是我们假设对于比 \( n \) 小的规模的递归已经符合 \( O(n \log n) \) 的上界形式。

### 2. **将归纳假设代入递归关系式**：
递归关系式给出的是：

\[
T(n) = 2T(\lfloor n/2 \rfloor) + \Theta(n)
\]

根据归纳假设，将 \( T(\lfloor n/2 \rfloor) \) 替换为 \( c \lfloor n/2 \rfloor \log(\lfloor n/2 \rfloor) \)：

\[
T(n) \leq 2 \cdot c \lfloor n/2 \rfloor \log(\lfloor n/2 \rfloor) + \Theta(n)
\]

### 3. **去掉地板函数**：
在递归复杂度分析中，地板函数（\( \lfloor n/2 \rfloor \)）通常可以忽略，因为它不会影响渐进复杂度。所以将 \( \lfloor n/2 \rfloor \) 替换为 \( n/2 \) 进行简化：

\[
T(n) \leq 2 \cdot c (n/2) \log(n/2) + \Theta(n)
\]

### 4. **化简对数项**：
将对数项 \( \log(n/2) \) 进行化简：

\[
\log(n/2) = \log n - \log 2
\]

因此表达式变为：

\[
T(n) \leq c n \log(n/2) + \Theta(n) = c n (\log n - \log 2) + \Theta(n)
\]

### 5. **继续化简**：
将对数项展开后：

\[
T(n) = c n \log n - c n \log 2 + \Theta(n)
\]

因为 \( \log 2 \) 是常数，化简成：

\[
T(n) = c n \log n - c n + \Theta(n)
\]

### 6. **将 \( \Theta(n) \) 合并到常数项中**：
我们可以认为 \( \Theta(n) \) 是一个线性项（即某个常数倍的 \( n \)），因此如果常数 \( c \) 足够大，我们可以让 \( c n \) 压过 \( \Theta(n) \) 中的常数部分。因此得到：

\[
T(n) \leq c n \log n
\]

最后一步要求选择 \( n_0 \) 和 \( c \) 足够大，使得 \( c n \) 在 \( n \geq 2n_0 \) 的条件下能够支配 \( \Theta(n) \) 中的线性项，这样上界的形式 \( T(n) \leq c n \log n \) 成立。

### 总结：
整个推导过程如下：
1. 假设 \( T(\lfloor n/2 \rfloor) \leq c \lfloor n/2 \rfloor \log(\lfloor n/2 \rfloor) \)。
2. 将假设代入递归关系式 \( T(n) = 2T(\lfloor n/2 \rfloor) + \Theta(n) \)。
3. 去掉地板函数，简化对数项。
4. 最终化简出 \( T(n) \leq c n \log n \)，通过适当选择常数 \( c \) 和 \( n_0 \)，使这个不等式成立。

这就是替代法证明 \( T(n) = O(n \log n) \) 的完整推导过程。


### 如何处理数学归纳法中的基例（base case）

1. **归纳步骤已经证明了对较大 \( n \) 的情况成立**：
   之前通过递归和归纳假设，已经证明了对于 \( n \geq 2n_0 \) 的情况，时间复杂度满足 \( T(n) \leq c n \log n \)。但这还不够，数学归纳法要求也要验证基例（即 \( n \) 较小时的情况）。

2. **需要证明基例情况成立**：
   我们还需要证明对于较小的 \( n \)，即 \( n_0 \leq n < 2n_0 \) 的情况，归纳假设 \( T(n) \leq c n \log n \) 也是成立的。这些是基准情况（base cases），不能通过递归直接推导出来，必须单独验证。

3. **选定 \( n_0 = 2 \)**：
   在递归关系式中，基例的区间没有明确给出，所以为了方便，我们选定 \( n_0 = 2 \)。这意味着，我们要验证在 \( n = 2 \) 和 \( n = 3 \) 的情况下，归纳假设依然成立。

4. **确保对数是正值**：
   只要 \( n_0 > 1 \)，对数 \( \log n \) 是正值，这意味着 \( n \log n > 0 \)，所以不会出现负值的情况。因此可以在 \( n_0 = 2 \) 及其以上的 \( n \) 值进行验证。

5. **基例 \( T(2) \) 和 \( T(3) \)** 是常数：
   由于没有明确的基准值，按照惯例，认为 \( T(2) \) 和 \( T(3) \) 是常数值（在算法实际运行中，当输入规模为 2 或 3 时，运行时间是常数时间）。也就是说，递归在这些较小输入上不再继续，直接返回常数值。

6. **选择常数 \( c \)**：
   为了使归纳假设对 \( n = 2 \) 和 \( n = 3 \) 也成立，我们选择 \( c \) 为 \( T(2) \) 和 \( T(3) \) 的最大值，即：

   \[
   c = \max(T(2), T(3))
   \]

   - 对于 \( n = 2 \)，我们需要验证 \( T(2) \leq c \cdot 2 \log 2 \)。
   - 对于 \( n = 3 \)，我们需要验证 \( T(3) \leq c \cdot 3 \log 3 \)。

   因为 \( T(2) \) 和 \( T(3) \) 是常数值，而 \( 2 \log 2 \) 和 \( 3 \log 3 \) 也都是正的常数值，所以我们可以选取 \( c \) 来满足这些不等式，从而确保基例的归纳假设成立。

